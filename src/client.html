<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ExpoCloud.src.client API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ExpoCloud.src.client</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># @ Meir Goldenberg The module is part of the ExpoCloud Framework

from multiprocessing import Process, Value, Queue, cpu_count
import time
import socket

from src.util import myprint
from src.constants import Verbosity

from src import util
from src.util import InstanceRole, MessageType
from src.constants import Constants

# Responsible for a single task
class Worker(Process):
    def __init__(self, id, task, queue):
        Process.__init__(self)
        self.id = id
        self.task = task
        self.queue = queue
        self.timestamp = Value(&#39;d&#39;, 0)
        self.killed = False # takes time after kill() before is_alive() == False

    def my_kill(self):
        self.killed = True
        self.kill()

    def run(self):
        myprint(Verbosity.workers, f&#34;Worker {self.id} with {self.task.id}&#34;)
        self.timestamp.value = time.time()
        self.queue.put((MessageType.WORKER_STARTED, None))
        result = self.task.run()
        self.queue.put((MessageType.WORKER_DONE, result))

class Client:
    &#34;&#34;&#34;
    The main client class.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        Perform handshake with the server and create the queues:
        self.bye_q - to inform the server when this client is done.
        self.request_tasks_q - to request tasks from the server.
        self.grant_tasks_q - to receive tasks from the server.
        &#34;&#34;&#34;
        self.begin_timestamp = time.time()
        self.workers = []
        self.next_worker_id = 0
        self.name = socket.gethostname()
        self.titles_flag = False # whether have already output column titles
        self.tasks = [] # tasks not yet assigned to workers
        self.done_tasks = []
        self.n_requested = 0 # number of tasks requested, but not granted yet
        self.no_further_tasks = False # True - no more tasks at the server
        self.capacity = min(cpu_count(), util.command_arg_max_cpus())

        self.port_primary = util.get_unused_port()
        self.manager_primary = util.make_manager(
            [&#39;outbound&#39;, &#39;inbound&#39;], self.port_primary)
        self.port_backup = util.get_unused_port()
        self.manager_backup = util.make_manager(
            [&#39;outbound&#39;, &#39;inbound&#39;], self.port_backup)

        self.to_primary_q, self.from_primary_q, \
        self.to_backup_q, self.from_backup_q = \
            self.manager_primary.outbound(), \
            self.manager_primary.inbound(), \
            self.manager_backup.outbound(), \
            self.manager_backup.inbound()

        self.message_id = 0 # id of the next message
        util.handshake(
            InstanceRole.CLIENT, self.port_primary, self.port_backup)
        self.last_health_update = time.time()

        self.stopped_flag = False
        self.received_ids = [] # ids of messages received from primary server
                               # not yet matched by messages from backup server
        
        # When RESUME is received, the backup server will never match the messages currently in from_primary_q. Hence, when these messages are processed, their ids should not be stored. The following variable remembers the number of such messages.
        self.pass_received_ids = 0

    #region UTILITY METHODS FOR COMMUNICATING WITH THE SERVERS

    def message_to_servers(self, type, body):
        &#34;&#34;&#34;
        Send message to both primary and backup servers.
        &#34;&#34;&#34;
        try:
            self.to_primary_q.put((self.message_id, type, body))
            self.to_backup_q.put((self.message_id, type, body))
            self.message_id += 1
        except Exception as e:
            pass # server failure is handled elsewhere
    
    def event_to_servers(self, descr, worker=None, task = None):
        worker_id = worker.id if worker else None
        task = task if task else worker.task
        descr = f&#34;{round(time.time()-self.begin_timestamp, 2)},{descr},{worker_id},{task.id},&#34;  + util.tuple_to_csv(task.parameters())
        self.message_to_servers(MessageType.LOG, descr)

    #endregion COMMUNICATION WITH THE SERVERS

    #region PROCESSING MESSAGES FROM PRIMARY SERVER
 
    def process_grant_tasks(self, tasks):
        self.n_requested -= len(tasks)
        self.tasks += tasks

        if not self.titles_flag:
            # column titles
            self.titles_flag = True
            self.message_to_servers( \
                MessageType.LOG, 
                &#34;timestamp,descr,worker_id,task_id,&#34; + \
                util.tuple_to_csv(tasks[0].parameter_titles()))
        
        for t in tasks:
            self.event_to_servers(&#34;received&#34;, task=t)
    
    def apply_domino_effect(self, hard):
        &#34;&#34;&#34;
        1. Kills the workers that execute tasks harder than `hard`.
        2. Removes tasks harder than `hard` from self.tasks.
        &#34;&#34;&#34;
        for w in self.workers:
            if w.killed: continue
            if w.task.hardness &gt;= hard:
                self.event_to_servers(&#34;domino&#34;, w)
                w.my_kill()
                
        filter(lambda t: t.hardness &lt; hard, self.tasks)

    def process_no_further_tasks(self, _body):
        self.no_further_tasks = True

    def process_stop(self, _body):
        self.stopped_flag = True

    def process_resume(self, _body):
        self.stopped_flag = False
        myprint(Verbosity.message_sync,
                f&#34;Removing received_ids: {self.received_ids}&#34;)
        self.received_ids = []
        assert(self.pass_received_ids == 0)
        self.pass_received_ids = self.from_primary_q.qsize()
        myprint(Verbosity.message_sync,
                f&#34;Will pass {self.pass_received_ids} ids: {[self.from_primary_q.queue[i][0] for i in range(self.pass_received_ids)]}&#34;)

    def process_swap_queues(self, _body):
        self.to_primary_q, self.to_backup_q = \
            self.to_backup_q, self.to_primary_q
        self.from_primary_q, self.from_backup_q = \
            self.from_backup_q, self.from_primary_q
        
        self.port_primary, self.port_backup = \
            self.port_backup, self.port_primary
        self.manager_primary, self.manager_backup = \
            self.manager_backup, self.manager_primary

    def process_messages(self):
        while not self.from_primary_q.empty():
            id, type, body = self.from_primary_q.get_nowait()
            myprint(Verbosity.messages, f&#34;Primary server sent {id} {type}&#34;)
            {MessageType.GRANT_TASKS: self.process_grant_tasks,
             MessageType.APPLY_DOMINO_EFFECT: self.apply_domino_effect,
             MessageType.NO_FURTHER_TASKS: self.process_no_further_tasks,
             MessageType.STOP: self.process_stop,
             MessageType.RESUME: self.process_resume,
             MessageType.SWAP_QUEUES: self.process_swap_queues,
             } \
             [type](body)

            assert(self.pass_received_ids &gt;= 0)
            if id:
                if self.pass_received_ids:
                    myprint(Verbosity.message_sync,
                            f&#34;Not appending into received_ids (self.pass_received_ids={self.pass_received_ids})&#34;)
                    self.pass_received_ids -= 1
                else:
                    self.received_ids.append(id)                
        
        while self.received_ids and not self.from_backup_q.empty():
            id, type, body = self.from_backup_q.get_nowait()
            myprint(Verbosity.messages, 
                    f&#34;Backup server sent {id} {type}: {body}&#34;)
            received_id = self.received_ids.pop(0)
            myprint(Verbosity.message_sync, 
                    f&#34;Primary server had sent received_id={received_id}&#34;)
            assert(id == received_id)
    
    #endregion PROCESSING MESSAGES FROM PRIMARY SERVER

    #region PROCESSING WORKERS

    def  process_worker_started(self, worker, _body):
        self.event_to_servers(&#34;starting&#34;, worker)
    
    def  process_worker_done(self, worker, result):
        self.message_to_servers(
            MessageType.RESULT, (worker.task.id, result))
        self.event_to_servers(&#34;done&#34;, worker)

    def process_worker_messages(self):
        for w in self.workers:
            while not w.queue.empty():
                type, body = w.queue.get_nowait()
                {MessageType.WORKER_STARTED: 
                    self.process_worker_started,
                 MessageType.WORKER_DONE: self.process_worker_done,
                } [type](w, body)

    def collect_done(self):
        self.workers = list(\
            filter(lambda worker: worker.is_alive(), 
                   self.workers))

    def kill_overdue(self):
        for worker in self.workers:
            if worker.killed: continue
            before = worker.timestamp.value
            if before and time.time() - before &gt; worker.task.timeout:
                self.event_to_servers(&#34;timeout&#34;, worker)
                worker.my_kill()
                self.message_to_servers(
                    MessageType.REPORT_HARD_TASK, 
                    worker.task.id)                

    def process_workers(self):
        self.process_worker_messages()
        self.collect_done()
        self.kill_overdue()

    #endregion PROCESSING WORKERS

    def health_update(self):
        if time.time() - self.last_health_update &lt; \
           Constants.HEALTH_UPDATE_FREQUENCY: return
        self.message_to_servers(MessageType.HEALTH_UPDATE, None)
        self.last_health_update = time.time()

    def request_tasks(self, n: int):
        &#34;&#34;&#34;
        Request n tasks from the server.
        &#34;&#34;&#34;
        if n == 0: return
        self.n_requested += n
        self.message_to_servers(MessageType.REQUEST_TASKS, n)
    
    def occupy_workers(self):
        while len(self.workers) &lt; self.capacity and self.tasks:
            task = self.tasks.pop(0)
            worker = Worker(self.next_worker_id, task, Queue())
            self.next_worker_id += 1
            self.workers.append(worker)
            worker.start()

    def run(self):
        myprint(Verbosity.all, &#34;Starting...&#34;)
        while self.tasks or not self.no_further_tasks or self.workers:
            self.health_update()
            if not self.stopped_flag:
                self.process_workers()
                if not self.no_further_tasks:
                    n_tasks_in_pipeline = \
                        len(self.workers) + len(self.tasks) + self.n_requested
                    self.request_tasks(self.capacity - n_tasks_in_pipeline)
            self.process_messages()
            self.occupy_workers()
            time.sleep(Constants.CLIENT_CYCLE_WAIT)

        myprint(Verbosity.all, &#34;Sending BYE&#34;)       
        self.message_to_servers(MessageType.BYE, None)
        time.sleep(Constants.CLIENT_WAIT_AFTER_SENDING_BYE) 
        self.manager_primary.shutdown()
        self.manager_backup.shutdown()
        myprint(Verbosity.all, &#34;Done&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ExpoCloud.src.client.Client"><code class="flex name class">
<span>class <span class="ident">Client</span></span>
</code></dt>
<dd>
<div class="desc"><p>The main client class.</p>
<p>Perform handshake with the server and create the queues:
self.bye_q - to inform the server when this client is done.
self.request_tasks_q - to request tasks from the server.
self.grant_tasks_q - to receive tasks from the server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Client:
    &#34;&#34;&#34;
    The main client class.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        Perform handshake with the server and create the queues:
        self.bye_q - to inform the server when this client is done.
        self.request_tasks_q - to request tasks from the server.
        self.grant_tasks_q - to receive tasks from the server.
        &#34;&#34;&#34;
        self.begin_timestamp = time.time()
        self.workers = []
        self.next_worker_id = 0
        self.name = socket.gethostname()
        self.titles_flag = False # whether have already output column titles
        self.tasks = [] # tasks not yet assigned to workers
        self.done_tasks = []
        self.n_requested = 0 # number of tasks requested, but not granted yet
        self.no_further_tasks = False # True - no more tasks at the server
        self.capacity = min(cpu_count(), util.command_arg_max_cpus())

        self.port_primary = util.get_unused_port()
        self.manager_primary = util.make_manager(
            [&#39;outbound&#39;, &#39;inbound&#39;], self.port_primary)
        self.port_backup = util.get_unused_port()
        self.manager_backup = util.make_manager(
            [&#39;outbound&#39;, &#39;inbound&#39;], self.port_backup)

        self.to_primary_q, self.from_primary_q, \
        self.to_backup_q, self.from_backup_q = \
            self.manager_primary.outbound(), \
            self.manager_primary.inbound(), \
            self.manager_backup.outbound(), \
            self.manager_backup.inbound()

        self.message_id = 0 # id of the next message
        util.handshake(
            InstanceRole.CLIENT, self.port_primary, self.port_backup)
        self.last_health_update = time.time()

        self.stopped_flag = False
        self.received_ids = [] # ids of messages received from primary server
                               # not yet matched by messages from backup server
        
        # When RESUME is received, the backup server will never match the messages currently in from_primary_q. Hence, when these messages are processed, their ids should not be stored. The following variable remembers the number of such messages.
        self.pass_received_ids = 0

    #region UTILITY METHODS FOR COMMUNICATING WITH THE SERVERS

    def message_to_servers(self, type, body):
        &#34;&#34;&#34;
        Send message to both primary and backup servers.
        &#34;&#34;&#34;
        try:
            self.to_primary_q.put((self.message_id, type, body))
            self.to_backup_q.put((self.message_id, type, body))
            self.message_id += 1
        except Exception as e:
            pass # server failure is handled elsewhere
    
    def event_to_servers(self, descr, worker=None, task = None):
        worker_id = worker.id if worker else None
        task = task if task else worker.task
        descr = f&#34;{round(time.time()-self.begin_timestamp, 2)},{descr},{worker_id},{task.id},&#34;  + util.tuple_to_csv(task.parameters())
        self.message_to_servers(MessageType.LOG, descr)

    #endregion COMMUNICATION WITH THE SERVERS

    #region PROCESSING MESSAGES FROM PRIMARY SERVER
 
    def process_grant_tasks(self, tasks):
        self.n_requested -= len(tasks)
        self.tasks += tasks

        if not self.titles_flag:
            # column titles
            self.titles_flag = True
            self.message_to_servers( \
                MessageType.LOG, 
                &#34;timestamp,descr,worker_id,task_id,&#34; + \
                util.tuple_to_csv(tasks[0].parameter_titles()))
        
        for t in tasks:
            self.event_to_servers(&#34;received&#34;, task=t)
    
    def apply_domino_effect(self, hard):
        &#34;&#34;&#34;
        1. Kills the workers that execute tasks harder than `hard`.
        2. Removes tasks harder than `hard` from self.tasks.
        &#34;&#34;&#34;
        for w in self.workers:
            if w.killed: continue
            if w.task.hardness &gt;= hard:
                self.event_to_servers(&#34;domino&#34;, w)
                w.my_kill()
                
        filter(lambda t: t.hardness &lt; hard, self.tasks)

    def process_no_further_tasks(self, _body):
        self.no_further_tasks = True

    def process_stop(self, _body):
        self.stopped_flag = True

    def process_resume(self, _body):
        self.stopped_flag = False
        myprint(Verbosity.message_sync,
                f&#34;Removing received_ids: {self.received_ids}&#34;)
        self.received_ids = []
        assert(self.pass_received_ids == 0)
        self.pass_received_ids = self.from_primary_q.qsize()
        myprint(Verbosity.message_sync,
                f&#34;Will pass {self.pass_received_ids} ids: {[self.from_primary_q.queue[i][0] for i in range(self.pass_received_ids)]}&#34;)

    def process_swap_queues(self, _body):
        self.to_primary_q, self.to_backup_q = \
            self.to_backup_q, self.to_primary_q
        self.from_primary_q, self.from_backup_q = \
            self.from_backup_q, self.from_primary_q
        
        self.port_primary, self.port_backup = \
            self.port_backup, self.port_primary
        self.manager_primary, self.manager_backup = \
            self.manager_backup, self.manager_primary

    def process_messages(self):
        while not self.from_primary_q.empty():
            id, type, body = self.from_primary_q.get_nowait()
            myprint(Verbosity.messages, f&#34;Primary server sent {id} {type}&#34;)
            {MessageType.GRANT_TASKS: self.process_grant_tasks,
             MessageType.APPLY_DOMINO_EFFECT: self.apply_domino_effect,
             MessageType.NO_FURTHER_TASKS: self.process_no_further_tasks,
             MessageType.STOP: self.process_stop,
             MessageType.RESUME: self.process_resume,
             MessageType.SWAP_QUEUES: self.process_swap_queues,
             } \
             [type](body)

            assert(self.pass_received_ids &gt;= 0)
            if id:
                if self.pass_received_ids:
                    myprint(Verbosity.message_sync,
                            f&#34;Not appending into received_ids (self.pass_received_ids={self.pass_received_ids})&#34;)
                    self.pass_received_ids -= 1
                else:
                    self.received_ids.append(id)                
        
        while self.received_ids and not self.from_backup_q.empty():
            id, type, body = self.from_backup_q.get_nowait()
            myprint(Verbosity.messages, 
                    f&#34;Backup server sent {id} {type}: {body}&#34;)
            received_id = self.received_ids.pop(0)
            myprint(Verbosity.message_sync, 
                    f&#34;Primary server had sent received_id={received_id}&#34;)
            assert(id == received_id)
    
    #endregion PROCESSING MESSAGES FROM PRIMARY SERVER

    #region PROCESSING WORKERS

    def  process_worker_started(self, worker, _body):
        self.event_to_servers(&#34;starting&#34;, worker)
    
    def  process_worker_done(self, worker, result):
        self.message_to_servers(
            MessageType.RESULT, (worker.task.id, result))
        self.event_to_servers(&#34;done&#34;, worker)

    def process_worker_messages(self):
        for w in self.workers:
            while not w.queue.empty():
                type, body = w.queue.get_nowait()
                {MessageType.WORKER_STARTED: 
                    self.process_worker_started,
                 MessageType.WORKER_DONE: self.process_worker_done,
                } [type](w, body)

    def collect_done(self):
        self.workers = list(\
            filter(lambda worker: worker.is_alive(), 
                   self.workers))

    def kill_overdue(self):
        for worker in self.workers:
            if worker.killed: continue
            before = worker.timestamp.value
            if before and time.time() - before &gt; worker.task.timeout:
                self.event_to_servers(&#34;timeout&#34;, worker)
                worker.my_kill()
                self.message_to_servers(
                    MessageType.REPORT_HARD_TASK, 
                    worker.task.id)                

    def process_workers(self):
        self.process_worker_messages()
        self.collect_done()
        self.kill_overdue()

    #endregion PROCESSING WORKERS

    def health_update(self):
        if time.time() - self.last_health_update &lt; \
           Constants.HEALTH_UPDATE_FREQUENCY: return
        self.message_to_servers(MessageType.HEALTH_UPDATE, None)
        self.last_health_update = time.time()

    def request_tasks(self, n: int):
        &#34;&#34;&#34;
        Request n tasks from the server.
        &#34;&#34;&#34;
        if n == 0: return
        self.n_requested += n
        self.message_to_servers(MessageType.REQUEST_TASKS, n)
    
    def occupy_workers(self):
        while len(self.workers) &lt; self.capacity and self.tasks:
            task = self.tasks.pop(0)
            worker = Worker(self.next_worker_id, task, Queue())
            self.next_worker_id += 1
            self.workers.append(worker)
            worker.start()

    def run(self):
        myprint(Verbosity.all, &#34;Starting...&#34;)
        while self.tasks or not self.no_further_tasks or self.workers:
            self.health_update()
            if not self.stopped_flag:
                self.process_workers()
                if not self.no_further_tasks:
                    n_tasks_in_pipeline = \
                        len(self.workers) + len(self.tasks) + self.n_requested
                    self.request_tasks(self.capacity - n_tasks_in_pipeline)
            self.process_messages()
            self.occupy_workers()
            time.sleep(Constants.CLIENT_CYCLE_WAIT)

        myprint(Verbosity.all, &#34;Sending BYE&#34;)       
        self.message_to_servers(MessageType.BYE, None)
        time.sleep(Constants.CLIENT_WAIT_AFTER_SENDING_BYE) 
        self.manager_primary.shutdown()
        self.manager_backup.shutdown()
        myprint(Verbosity.all, &#34;Done&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ExpoCloud.src.client.Client.apply_domino_effect"><code class="name flex">
<span>def <span class="ident">apply_domino_effect</span></span>(<span>self, hard)</span>
</code></dt>
<dd>
<div class="desc"><ol>
<li>Kills the workers that execute tasks harder than <code>hard</code>.</li>
<li>Removes tasks harder than <code>hard</code> from self.tasks.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_domino_effect(self, hard):
    &#34;&#34;&#34;
    1. Kills the workers that execute tasks harder than `hard`.
    2. Removes tasks harder than `hard` from self.tasks.
    &#34;&#34;&#34;
    for w in self.workers:
        if w.killed: continue
        if w.task.hardness &gt;= hard:
            self.event_to_servers(&#34;domino&#34;, w)
            w.my_kill()
            
    filter(lambda t: t.hardness &lt; hard, self.tasks)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.client.Client.collect_done"><code class="name flex">
<span>def <span class="ident">collect_done</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect_done(self):
    self.workers = list(\
        filter(lambda worker: worker.is_alive(), 
               self.workers))</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.client.Client.event_to_servers"><code class="name flex">
<span>def <span class="ident">event_to_servers</span></span>(<span>self, descr, worker=None, task=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event_to_servers(self, descr, worker=None, task = None):
    worker_id = worker.id if worker else None
    task = task if task else worker.task
    descr = f&#34;{round(time.time()-self.begin_timestamp, 2)},{descr},{worker_id},{task.id},&#34;  + util.tuple_to_csv(task.parameters())
    self.message_to_servers(MessageType.LOG, descr)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.client.Client.health_update"><code class="name flex">
<span>def <span class="ident">health_update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def health_update(self):
    if time.time() - self.last_health_update &lt; \
       Constants.HEALTH_UPDATE_FREQUENCY: return
    self.message_to_servers(MessageType.HEALTH_UPDATE, None)
    self.last_health_update = time.time()</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.client.Client.kill_overdue"><code class="name flex">
<span>def <span class="ident">kill_overdue</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kill_overdue(self):
    for worker in self.workers:
        if worker.killed: continue
        before = worker.timestamp.value
        if before and time.time() - before &gt; worker.task.timeout:
            self.event_to_servers(&#34;timeout&#34;, worker)
            worker.my_kill()
            self.message_to_servers(
                MessageType.REPORT_HARD_TASK, 
                worker.task.id)                </code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.client.Client.message_to_servers"><code class="name flex">
<span>def <span class="ident">message_to_servers</span></span>(<span>self, type, body)</span>
</code></dt>
<dd>
<div class="desc"><p>Send message to both primary and backup servers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def message_to_servers(self, type, body):
    &#34;&#34;&#34;
    Send message to both primary and backup servers.
    &#34;&#34;&#34;
    try:
        self.to_primary_q.put((self.message_id, type, body))
        self.to_backup_q.put((self.message_id, type, body))
        self.message_id += 1
    except Exception as e:
        pass # server failure is handled elsewhere</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.client.Client.occupy_workers"><code class="name flex">
<span>def <span class="ident">occupy_workers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def occupy_workers(self):
    while len(self.workers) &lt; self.capacity and self.tasks:
        task = self.tasks.pop(0)
        worker = Worker(self.next_worker_id, task, Queue())
        self.next_worker_id += 1
        self.workers.append(worker)
        worker.start()</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.client.Client.process_grant_tasks"><code class="name flex">
<span>def <span class="ident">process_grant_tasks</span></span>(<span>self, tasks)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_grant_tasks(self, tasks):
    self.n_requested -= len(tasks)
    self.tasks += tasks

    if not self.titles_flag:
        # column titles
        self.titles_flag = True
        self.message_to_servers( \
            MessageType.LOG, 
            &#34;timestamp,descr,worker_id,task_id,&#34; + \
            util.tuple_to_csv(tasks[0].parameter_titles()))
    
    for t in tasks:
        self.event_to_servers(&#34;received&#34;, task=t)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.client.Client.process_messages"><code class="name flex">
<span>def <span class="ident">process_messages</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_messages(self):
    while not self.from_primary_q.empty():
        id, type, body = self.from_primary_q.get_nowait()
        myprint(Verbosity.messages, f&#34;Primary server sent {id} {type}&#34;)
        {MessageType.GRANT_TASKS: self.process_grant_tasks,
         MessageType.APPLY_DOMINO_EFFECT: self.apply_domino_effect,
         MessageType.NO_FURTHER_TASKS: self.process_no_further_tasks,
         MessageType.STOP: self.process_stop,
         MessageType.RESUME: self.process_resume,
         MessageType.SWAP_QUEUES: self.process_swap_queues,
         } \
         [type](body)

        assert(self.pass_received_ids &gt;= 0)
        if id:
            if self.pass_received_ids:
                myprint(Verbosity.message_sync,
                        f&#34;Not appending into received_ids (self.pass_received_ids={self.pass_received_ids})&#34;)
                self.pass_received_ids -= 1
            else:
                self.received_ids.append(id)                
    
    while self.received_ids and not self.from_backup_q.empty():
        id, type, body = self.from_backup_q.get_nowait()
        myprint(Verbosity.messages, 
                f&#34;Backup server sent {id} {type}: {body}&#34;)
        received_id = self.received_ids.pop(0)
        myprint(Verbosity.message_sync, 
                f&#34;Primary server had sent received_id={received_id}&#34;)
        assert(id == received_id)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.client.Client.process_no_further_tasks"><code class="name flex">
<span>def <span class="ident">process_no_further_tasks</span></span>(<span>self, _body)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_no_further_tasks(self, _body):
    self.no_further_tasks = True</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.client.Client.process_resume"><code class="name flex">
<span>def <span class="ident">process_resume</span></span>(<span>self, _body)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_resume(self, _body):
    self.stopped_flag = False
    myprint(Verbosity.message_sync,
            f&#34;Removing received_ids: {self.received_ids}&#34;)
    self.received_ids = []
    assert(self.pass_received_ids == 0)
    self.pass_received_ids = self.from_primary_q.qsize()
    myprint(Verbosity.message_sync,
            f&#34;Will pass {self.pass_received_ids} ids: {[self.from_primary_q.queue[i][0] for i in range(self.pass_received_ids)]}&#34;)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.client.Client.process_stop"><code class="name flex">
<span>def <span class="ident">process_stop</span></span>(<span>self, _body)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_stop(self, _body):
    self.stopped_flag = True</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.client.Client.process_swap_queues"><code class="name flex">
<span>def <span class="ident">process_swap_queues</span></span>(<span>self, _body)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_swap_queues(self, _body):
    self.to_primary_q, self.to_backup_q = \
        self.to_backup_q, self.to_primary_q
    self.from_primary_q, self.from_backup_q = \
        self.from_backup_q, self.from_primary_q
    
    self.port_primary, self.port_backup = \
        self.port_backup, self.port_primary
    self.manager_primary, self.manager_backup = \
        self.manager_backup, self.manager_primary</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.client.Client.process_worker_done"><code class="name flex">
<span>def <span class="ident">process_worker_done</span></span>(<span>self, worker, result)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def  process_worker_done(self, worker, result):
    self.message_to_servers(
        MessageType.RESULT, (worker.task.id, result))
    self.event_to_servers(&#34;done&#34;, worker)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.client.Client.process_worker_messages"><code class="name flex">
<span>def <span class="ident">process_worker_messages</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_worker_messages(self):
    for w in self.workers:
        while not w.queue.empty():
            type, body = w.queue.get_nowait()
            {MessageType.WORKER_STARTED: 
                self.process_worker_started,
             MessageType.WORKER_DONE: self.process_worker_done,
            } [type](w, body)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.client.Client.process_worker_started"><code class="name flex">
<span>def <span class="ident">process_worker_started</span></span>(<span>self, worker, _body)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def  process_worker_started(self, worker, _body):
    self.event_to_servers(&#34;starting&#34;, worker)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.client.Client.process_workers"><code class="name flex">
<span>def <span class="ident">process_workers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_workers(self):
    self.process_worker_messages()
    self.collect_done()
    self.kill_overdue()</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.client.Client.request_tasks"><code class="name flex">
<span>def <span class="ident">request_tasks</span></span>(<span>self, n: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Request n tasks from the server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def request_tasks(self, n: int):
    &#34;&#34;&#34;
    Request n tasks from the server.
    &#34;&#34;&#34;
    if n == 0: return
    self.n_requested += n
    self.message_to_servers(MessageType.REQUEST_TASKS, n)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.client.Client.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    myprint(Verbosity.all, &#34;Starting...&#34;)
    while self.tasks or not self.no_further_tasks or self.workers:
        self.health_update()
        if not self.stopped_flag:
            self.process_workers()
            if not self.no_further_tasks:
                n_tasks_in_pipeline = \
                    len(self.workers) + len(self.tasks) + self.n_requested
                self.request_tasks(self.capacity - n_tasks_in_pipeline)
        self.process_messages()
        self.occupy_workers()
        time.sleep(Constants.CLIENT_CYCLE_WAIT)

    myprint(Verbosity.all, &#34;Sending BYE&#34;)       
    self.message_to_servers(MessageType.BYE, None)
    time.sleep(Constants.CLIENT_WAIT_AFTER_SENDING_BYE) 
    self.manager_primary.shutdown()
    self.manager_backup.shutdown()
    myprint(Verbosity.all, &#34;Done&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ExpoCloud.src.client.Worker"><code class="flex name class">
<span>class <span class="ident">Worker</span></span>
<span>(</span><span>id, task, queue)</span>
</code></dt>
<dd>
<div class="desc"><p>Process objects represent activity that is run in a separate process</p>
<p>The class is analogous to <code>threading.Thread</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Worker(Process):
    def __init__(self, id, task, queue):
        Process.__init__(self)
        self.id = id
        self.task = task
        self.queue = queue
        self.timestamp = Value(&#39;d&#39;, 0)
        self.killed = False # takes time after kill() before is_alive() == False

    def my_kill(self):
        self.killed = True
        self.kill()

    def run(self):
        myprint(Verbosity.workers, f&#34;Worker {self.id} with {self.task.id}&#34;)
        self.timestamp.value = time.time()
        self.queue.put((MessageType.WORKER_STARTED, None))
        result = self.task.run()
        self.queue.put((MessageType.WORKER_DONE, result))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>multiprocessing.context.Process</li>
<li>multiprocessing.process.BaseProcess</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ExpoCloud.src.client.Worker.my_kill"><code class="name flex">
<span>def <span class="ident">my_kill</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def my_kill(self):
    self.killed = True
    self.kill()</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.client.Worker.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to be run in sub-process; can be overridden in sub-class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    myprint(Verbosity.workers, f&#34;Worker {self.id} with {self.task.id}&#34;)
    self.timestamp.value = time.time()
    self.queue.put((MessageType.WORKER_STARTED, None))
    result = self.task.run()
    self.queue.put((MessageType.WORKER_DONE, result))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ExpoCloud.src" href="index.html">ExpoCloud.src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ExpoCloud.src.client.Client" href="#ExpoCloud.src.client.Client">Client</a></code></h4>
<ul class="">
<li><code><a title="ExpoCloud.src.client.Client.apply_domino_effect" href="#ExpoCloud.src.client.Client.apply_domino_effect">apply_domino_effect</a></code></li>
<li><code><a title="ExpoCloud.src.client.Client.collect_done" href="#ExpoCloud.src.client.Client.collect_done">collect_done</a></code></li>
<li><code><a title="ExpoCloud.src.client.Client.event_to_servers" href="#ExpoCloud.src.client.Client.event_to_servers">event_to_servers</a></code></li>
<li><code><a title="ExpoCloud.src.client.Client.health_update" href="#ExpoCloud.src.client.Client.health_update">health_update</a></code></li>
<li><code><a title="ExpoCloud.src.client.Client.kill_overdue" href="#ExpoCloud.src.client.Client.kill_overdue">kill_overdue</a></code></li>
<li><code><a title="ExpoCloud.src.client.Client.message_to_servers" href="#ExpoCloud.src.client.Client.message_to_servers">message_to_servers</a></code></li>
<li><code><a title="ExpoCloud.src.client.Client.occupy_workers" href="#ExpoCloud.src.client.Client.occupy_workers">occupy_workers</a></code></li>
<li><code><a title="ExpoCloud.src.client.Client.process_grant_tasks" href="#ExpoCloud.src.client.Client.process_grant_tasks">process_grant_tasks</a></code></li>
<li><code><a title="ExpoCloud.src.client.Client.process_messages" href="#ExpoCloud.src.client.Client.process_messages">process_messages</a></code></li>
<li><code><a title="ExpoCloud.src.client.Client.process_no_further_tasks" href="#ExpoCloud.src.client.Client.process_no_further_tasks">process_no_further_tasks</a></code></li>
<li><code><a title="ExpoCloud.src.client.Client.process_resume" href="#ExpoCloud.src.client.Client.process_resume">process_resume</a></code></li>
<li><code><a title="ExpoCloud.src.client.Client.process_stop" href="#ExpoCloud.src.client.Client.process_stop">process_stop</a></code></li>
<li><code><a title="ExpoCloud.src.client.Client.process_swap_queues" href="#ExpoCloud.src.client.Client.process_swap_queues">process_swap_queues</a></code></li>
<li><code><a title="ExpoCloud.src.client.Client.process_worker_done" href="#ExpoCloud.src.client.Client.process_worker_done">process_worker_done</a></code></li>
<li><code><a title="ExpoCloud.src.client.Client.process_worker_messages" href="#ExpoCloud.src.client.Client.process_worker_messages">process_worker_messages</a></code></li>
<li><code><a title="ExpoCloud.src.client.Client.process_worker_started" href="#ExpoCloud.src.client.Client.process_worker_started">process_worker_started</a></code></li>
<li><code><a title="ExpoCloud.src.client.Client.process_workers" href="#ExpoCloud.src.client.Client.process_workers">process_workers</a></code></li>
<li><code><a title="ExpoCloud.src.client.Client.request_tasks" href="#ExpoCloud.src.client.Client.request_tasks">request_tasks</a></code></li>
<li><code><a title="ExpoCloud.src.client.Client.run" href="#ExpoCloud.src.client.Client.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ExpoCloud.src.client.Worker" href="#ExpoCloud.src.client.Worker">Worker</a></code></h4>
<ul class="">
<li><code><a title="ExpoCloud.src.client.Worker.my_kill" href="#ExpoCloud.src.client.Worker.my_kill">my_kill</a></code></li>
<li><code><a title="ExpoCloud.src.client.Worker.run" href="#ExpoCloud.src.client.Worker.run">run</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>