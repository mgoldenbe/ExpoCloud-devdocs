<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ExpoCloud.src.server API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ExpoCloud.src.server</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># @ Meir Goldenberg The module is part of the ExpoCloud Framework

import pickle
import subprocess
import time
import os
import sys
import traceback

from src.util import myprint
from src.constants import Verbosity

from src import util
from src.util import InstanceRole, MessageType, handle_exception, my_ip
from src.constants import Constants
from src.instance import Instance, ClientInstance, BackupServerInstance, PrimaryServerInstance, is_primary, is_backup, is_client

class Server():
    &#34;&#34;&#34;
    An instance of this class is either a primary or a backup server.
    &#34;&#34;&#34;
    def __init__(self, tasks, engine, backup, 
                 max_clients = None, max_cpus_per_client = None, 
                 min_group_size = 0):
        &#34;&#34;&#34;
        Note that this constructor is only ever involked for building the first primary server.
        `backup` - whether a backup server should be used.
        `min_group_size` - minimal size of group defined by the Task&#39;s `group_parameter_titles` method.
        &#34;&#34;&#34;
        myprint(Verbosity.all, &#34;Constructing the server&#34;)
        self.role = InstanceRole.PRIMARY_SERVER
        self.port = util.get_unused_port()
        self.engine = engine
        self.backup = backup
        self.max_clients = max_clients
        self.max_cpus_per_client = max_cpus_per_client
        self.clients = []
        self.clients_stopped_timestamp = None

        self.init_handshake_q()

        # Store original order for results output, then sort by difficulty
        for i, t in enumerate(tasks): 
            t.orig_id = i
        self.tasks = sorted(tasks, key = lambda t: t.hardness)
        self.next_task = 0 # next task to be given to clients
        self.tasks_from_failed = [] # tasks from failed clients to reassign
        self.min_hard = [] # hardness for each minimally hard task
        self.min_group_size = min_group_size

        for i, t in enumerate(self.tasks):
            t.id = i
            t.result = None
        
        self.output_folder = util.output_folder()
        os.makedirs(self.output_folder, exist_ok=True)
        
        self.primary_server = None
        self.backup_server = None
        self.to_client_id = 1000 # id of the next outbound message to a client
        
    def __del__(self):
        myprint(Verbosity.all, &#34;Shutting down&#34;)
        if self.is_primary():
            self.handshake_manager.shutdown()

    def run(self):
        if self.is_primary():
            myprint(Verbosity.all, 
                    f&#34;Got {len(self.tasks)} tasks and ready for clients&#34;)

        try:
            printed_results = False
            while True:
                self.send_health_update()
                if self.is_primary(): self.accept_handshakes()
                self.handle_messages()
                if self.is_primary(): self.create_instance()
                self.kill_unhealthy_instances()
                if not printed_results:
                    if not (self.tasks_remain() or self.clients):
                        self.print_results()
                        printed_results = True
                time.sleep(Constants.SERVER_CYCLE_WAIT)
        except Exception as e:
            handle_exception(e, &#34;Exception in Server.run&#34;)
        

#region TASKS

    def tasks_remain(self):
        &#34;&#34;&#34;
        Return True if tasks to execute remain.
        &#34;&#34;&#34;
        return self.tasks_from_failed or self.next_task &lt; len(self.tasks)

    def is_hard(self, hardness):
        &#34;&#34;&#34;
        Check whether `hardness` is hard.
        &#34;&#34;&#34;
        for h in self.min_hard:
            if hardness &gt;= h: return True
        return False

    def print_results(self):
        &#34;&#34;&#34;
        Restore the original order of tasks and print results.
        &#34;&#34;&#34;
        myprint(Verbosity.all, &#34;Printing results&#34;)
        group_counts = {}
        for t in self.tasks:
            group = t.group_parameters()
            if group not in group_counts: group_counts[group] = 0
            group_counts[group] += 1

        self.tasks.sort(key = lambda t: t.orig_id)

        results_file = \
            open(os.path.join(self.output_folder, &#39;results.txt&#39;), &#34;w&#34;)
        print(util.tuple_to_csv(self.tasks[0].parameter_titles() + \
                                self.tasks[0].result_titles()),
              file = results_file)
        for t in self.tasks:
            if not t.result: continue
            if group_counts[t.group_parameters()] &gt;= self.min_group_size:
                print(util.tuple_to_csv(t.parameters() + t.result), 
                      file = results_file)
        
        results_file.close()
        myprint(Verbosity.all, &#34;Done printing results&#34;)

#endregion TASKS

#region ROLES

    def is_primary(self):
        return self.role == InstanceRole.PRIMARY_SERVER

    def is_backup(self):
        return self.role == InstanceRole.BACKUP_SERVER

    def assume_backup_role(self):
        &#34;&#34;&#34;
        This method is called after unpickling the primary server object, so as to convert it to a backup server one.
        &#34;&#34;&#34;
        assert(self.is_primary())
        self.role = InstanceRole.BACKUP_SERVER
        self.output_folder = util.output_folder(util.command_arg_name())
        self.backup_server = None

        self.port = util.get_unused_port()
        self.primary_server = PrimaryServerInstance(self.port)
        util.handshake(self.role, self.port)
        myprint(Verbosity.all, &#34;Handshake with primary server complete&#34;)

        if len(self.clients) &gt; 0 and not self.clients[-1].active_timestamp:
            self.clients = self.clients[:-1]
            
        for c in self.clients:
            c.shake_hands(self.role, self.output_folder)
            c.engine = None
            c.received_ids = []
    
    def assume_primary_role(self):
        &#34;&#34;&#34;
        Assume the role of the primary server. This is called when primary server failure is detected.
        &#34;&#34;&#34;
        assert(self.is_backup())
        self.role = InstanceRole.PRIMARY_SERVER
        self.primary_server = None
        self.backup_server = None
        self.init_handshake_q()
        for c in self.clients: c.engine = self.engine
    
    def handle_primary_server_failure(self):
        myprint(Verbosity.all, &#34;Handling primary server failure&#34;)
        self.assume_primary_role()
        for c in self.clients:
            if not c.active_timestamp: continue
            temp = c.outbound_q
            try:
                c.outbound_q, = util.get_guest_qs(
                    c.ip, c.port_primary, [&#39;inbound&#39;])
            except:
                myprint(Verbosity.all, 
                        &#34;Temporary connection to from_primary_q failed&#34;)
            self.message_to_instance(c, MessageType.SWAP_QUEUES, None)
            c.port_primary, c.port_backup = c.port_backup, c.port_primary
            c.outbound_q = temp
            c.engine = self.engine
#endregion ROLES

#region INSTANCES

    def init_handshake_q(self):
        self.handshake_manager = \
            util.make_manager([&#39;handshake_q&#39;], self.port)
        self.handshake_q = self.handshake_manager.handshake_q()

    def handshake_from_client(self, name, port_primary, port_backup):
        client = self.get_client(name)
        if not client:
            myprint(Verbosity.all, f&#34;Unknown client {name} tried to connect&#34;)
            return
        client.port_primary, client.port_backup = port_primary, port_backup
        client.shake_hands(self.role, self.output_folder)

        # inform the backup server
        myprint(Verbosity.all, f&#34;Informing backup server of {client.name}&#34;)
        self.message_to_instance(
            self.backup_server, MessageType.NEW_CLIENT, 
                (client.name, client.ip, 
                 port_primary, port_backup, client.active_timestamp))
    
    def handshake_from_backup(self, name, port):
        if name != self.backup_server.name:
            myprint(Verbosity.all, 
                    f&#34;Unknown backup server {name} tried to connect&#34;)
            return
        self.backup_server.port = port
        self.backup_server.shake_hands()
        self.resume_clients()

    def accept_handshakes(self):
        while not self.handshake_q.empty():
            body = self.handshake_q.get_nowait()
            role, rest = body[0], body[1:]
            
            if role == InstanceRole.CLIENT:
                if self.clients_stopped_timestamp:
                    self.handshake_q.put(body)
                    continue
                name, port_primary, port_backup = rest
                self.handshake_from_client(name, port_primary, port_backup)
                continue

            if role == InstanceRole.BACKUP_SERVER:
                name, port = rest
                self.handshake_from_backup(name, port)
                continue

            assert(False)

    def n_active_clients(self):
        return len(list(filter(lambda c: c.active_timestamp, self.clients)))

    def get_client(self, name):
        try:
            return next(filter(lambda c: c.name == name, self.clients))
        except:
            return None

    def kill_client(self, name):
        self.clients = \
            list(filter(lambda c: c.name != name, self.clients))

    def kill_instance(self, instance):
        if is_client(instance):
            self.kill_client(instance.name)
            return
        if is_backup(instance):
            self.backup_server = None
            return
        if is_primary(instance):
            self.handle_primary_server_failure()
            return
        assert(False)
    
    def create_backup_server_instance(self):
        def pickle_server():
            # exclude things that should not be pickled/unpickled
            temp_handshake_manager, temp_handhsake_q, temp_backup_server = \
                self.handshake_manager, self.handshake_q, self.backup_server
            self.handshake_manager, self.handshake_q, self.backup_server = \
                None, None, None
            client_files = []
            for c in self.clients:
                if not c.active_timestamp: continue
                client_files.append((c.events_file, c.exceptions_file))
                c.events_file, c.exceptions_file = None, None
            with open(util.pickled_file_name(self.output_folder), &#39;wb&#39;) as f:
                pickle.dump(self, f)
            self.handshake_manager, self.handshake_q, self.backup_server = \
                temp_handshake_manager, temp_handhsake_q, temp_backup_server
            for c in self.clients:
                if not c.active_timestamp: continue
                c.events_file, c.exceptions_file  = client_files.pop(0)
        
        def copy_output_folder():
            backup_output_folder = \
                    util.output_folder(self.backup_server.name)
            if not self.engine.is_local():
                util.remote_replace(
                    self.backup_server.ip, 
                    self.output_folder,
                    os.path.join(self.engine.root_folder, 
                                 backup_output_folder))
            else:
                command = f&#34;cp -r {self.output_folder} {backup_output_folder}&#34;
                subprocess.check_output(command, shell=True)

        # If not first backup server instance, make sure all clients got the STOP message and all client messages had been handled
        if self.clients_stopped_timestamp:
            if time.time() - self.clients_stopped_timestamp &lt;= \
               Constants.CLIENTS_TIME_TO_STOP: 
               return
            for c in self.clients:
                if self.messages_waiting(c): return

        if not self.backup_server:
            self.backup_server = BackupServerInstance(self.engine)
            self.backup_server_has_been_run = False
            myprint(Verbosity.all, 
                    f&#34;Created instance object for {self.backup_server.name}. Stopping clients...&#34;)
            self.stop_clients()
            return

        assert(self.backup_server)
        if not self.backup_server.ip:
            self.backup_server.create()
            return

        assert(self.backup_server.ip)
        if self.backup_server_has_been_run: return
        pickle_server()
        copy_output_folder()
        self.backup_server.run(self.port)
        self.backup_server_has_been_run = True

    def create_client_instance(self):
        # If no more tasks, don&#39;t create another client
        if not self.tasks_remain(): return

        # Make a client if all existing clients have ip
        if len(self.clients) == 0 or self.clients[-1].ip:
            client = ClientInstance(self.engine, self.tasks_from_failed)
            self.clients.append(client)
            myprint(Verbosity.all, f&#34;Created instance object for {client.name}&#34;)
        client = self.clients[-1]
        if not client.ip: client.create()
        if client.ip: client.run(self.port, self.max_cpus_per_client)

    def create_instance(self):
        if self.backup and \
            (not self.backup_server or not self.backup_server.active_timestamp):
            self.create_backup_server_instance()
        else:
            if (not self.max_clients) or \
               self.n_active_clients() &lt; self.max_clients:
                self.create_client_instance()

    def kill_unhealthy_instances(self):
        if self.is_backup():
            if not self.primary_server.is_healthy():
                self.handle_primary_server_failure()     
            return
        
        assert(self.is_primary())
        tasks_remain = self.tasks_remain()
        for c in self.clients:
            if c.is_healthy(tasks_remain): continue
            self.kill_client(c.name)
            self.message_to_instance(
                self.backup_server, MessageType.CLIENT_TERMINATED, c.name)
        
        if self.backup_server and \
           not self.backup_server.is_healthy(tasks_remain):
            self.backup_server = None

    def stop_clients(self):
        for c in self.clients:
            self.message_to_instance(c, MessageType.STOP, None)
        self.clients_stopped_timestamp = time.time()
    
    def resume_clients(self):
        for c in self.clients:
            self.message_to_instance(c, MessageType.RESUME, None)
        self.clients_stopped_timestamp = None

    def send_health_update(self):
        &#34;&#34;&#34;
        Send health update to the other server.
        &#34;&#34;&#34;
        other_server = \
            self.backup_server if self.is_primary() else self.primary_server
        self.message_to_instance(
            other_server, MessageType.HEALTH_UPDATE, None)

#endregion INSTANCES

#region MESSAGES
    def message_to_instance(self, instance, type, body):
        if not instance or not instance.active_timestamp:
            return

        try:
            message = (type, body)
            if is_client(instance) and \
               type not in [MessageType.STOP, MessageType.RESUME]:
                message = (self.to_client_id,) + message
                myprint(Verbosity.messages, 
                        f&#34;Sending message {self.to_client_id} ({type}) to {instance.name}&#34;)
                self.to_client_id += 1
            else:
                message = (None,) + message
            instance.outbound_q.put(message)
        except:
            myprint(Verbosity.all, f&#34;Sending to {instance.name} failed&#34;)
            myprint(Verbosity.failure_traceback, traceback.format_exc())
            self.kill_instance(instance)

    def messages_waiting(self, instance):
        &#34;&#34;&#34;
        Checks whether a message from `instance` can be read.
        If intance is invalid or is not active, return False.
        If there is no message in the inbound queue from the `instance`, return False. Otherwise return True, unless it is the backup server, `instance` is a client and there is no stored message id for this client.
        &#34;&#34;&#34;
        try:
            if not instance or not instance.active_timestamp: return False
            if instance.inbound_q.empty(): return False
            
            if self.is_primary(): return True

            assert(self.is_backup())
            if not is_client(instance): return True
            if not instance.received_ids: return False
            return True
        except:
            myprint(Verbosity.all, f&#34;Listening to {instance.name} failed&#34;)
            myprint(Verbosity.failure_traceback, traceback.format_exc())
            self.kill_instance(instance)

    def forward_message(self, instance, message_id, type, body):
        &#34;&#34;&#34;
        Forward messages from clients except health updates to backup server.
        &#34;&#34;&#34;
        if instance.role != InstanceRole.CLIENT: return
        self.message_to_instance(
            self.backup_server, MessageType.MESSAGE_FROM_CLIENT, 
            (instance.name, message_id, type, body))

#endregion MESSAGES

#region PROCESSING MESSAGES

    def process_health_update(self, instance, _body):
        instance.active_timestamp = time.time()

    def process_request_tasks(self, client: ClientInstance, n: int):
        tasks = []
        while n &gt; 0 and self.tasks_remain():
            task = self.tasks[self.next_task]
            if self.tasks_from_failed:
                task = self.tasks[self.tasks_from_failed.pop(0)]
            else:
                self.next_task += 1
            if self.is_hard(task.hardness):
                myprint(Verbosity.all, f&#34;Skipping hard task {task.id}&#34;)
                continue
            tasks.append(task)
            n -= 1
        if tasks:
            try:
                client.register_tasks(tasks)
                self.message_to_instance(
                    client, MessageType.GRANT_TASKS, tasks)
            except Exception as e:
                handle_exception(e, &#34;Failed to send tasks&#34;)
        if n &gt; 0:
            self.message_to_instance(
                client, MessageType.NO_FURTHER_TASKS, None)

    def process_log(self, client, descr):
        print(descr, file=client.events_file, flush=True)

    def process_exception(self, client, descr):
        print(descr, file=client.exceptions_file, flush=True)

    def process_result(self, client, body):
        id, result = body
        myprint(Verbosity.all, f&#34;Client {client.name} - result for task {id}&#34;)
        client.unregister_task(id)
        task = self.tasks[id]
        task.result = result
            
    def process_report_hard_task(self, _client, task_id):
        &#34;&#34;&#34;
        Handle the overdue task: 
        1. After checking again that the task is minimally hard, add the task to self.min_hard.
        2. Send this task to all clients for application of domino effect. Note: this is suboptimal as far as network capacity is concerned, but simplifies the server, which does not need to maintain which tasks are currently worked on by each client. 
        &#34;&#34;&#34;
        hardness = self.tasks[task_id].hardness
        if self.is_hard(hardness): return # not minimally hard
        self.min_hard.append(hardness)
        
        for c in self.clients:
            c.unregister_domino(self.tasks, hardness)
            self.message_to_instance(
                c, MessageType.APPLY_DOMINO_EFFECT, hardness)

    def process_bye(self, client, _body):
        assert(is_client(client))
        myprint(Verbosity.all, 
                f&#34;Got bye from {client.name}; {len(client.my_tasks)} registered tasks remain&#34;)
        self.kill_instance(client)

    def process_new_client(self, _instance, body):
        assert(self.is_backup())
        self.engine.next_instance_name(InstanceRole.CLIENT)
        client = ClientInstance(None, self.tasks_from_failed)
        client.name, client.ip, client.port_primary, client.port_backup, \
            client.active_timestamp = body
        myprint(Verbosity.all, f&#34;New {client.name}&#34;)
        client.shake_hands(self.role, self.output_folder)
        self.clients.append(client)

    def process_client_terminated(self, _instance, client_name):
        &#34;&#34;&#34;
        Process client failure reported by the primary server.
        &#34;&#34;&#34;
        assert(self.is_backup())
        myprint(Verbosity.all, 
                f&#34;Client {client_name} was terminated by primary server&#34;)
        self.kill_client(client_name)

    def process_message(self, instance, type, body):
        {
        MessageType.HEALTH_UPDATE: self.process_health_update,
        MessageType.REQUEST_TASKS: self.process_request_tasks,
        MessageType.RESULT: self.process_result,
        MessageType.REPORT_HARD_TASK: self.process_report_hard_task,
        MessageType.LOG: self.process_log,
        MessageType.EXCEPTION: self.process_exception,
        MessageType.BYE: self.process_bye,

        MessageType.NEW_CLIENT: self.process_new_client,
        MessageType.CLIENT_TERMINATED: self.process_client_terminated,
        } [type](instance, body)

    def handle_messages(self):
        &#34;&#34;&#34;
        Handle messages from instances.
        &#34;&#34;&#34;
        for instance in \
            self.clients + [self.primary_server, self.backup_server]:
            
            while self.messages_waiting(instance):
                message_id, type, body = instance.inbound_q.get_nowait()
                
                myprint(type != MessageType.HEALTH_UPDATE and \
                        Verbosity.all_non_health_messages, 
                        f&#34;Got {message_id} of type {type} from {instance.role}&#34;)
                if self.is_primary():
                    if is_client(instance):
                        if type != MessageType.HEALTH_UPDATE:
                            myprint(Verbosity.messages, 
                                    f&#34;Handling message {message_id} ({type}) from {instance.name}&#34;)
                            self.forward_message(instance, message_id, type, body)
                    self.process_message(instance, type, body)
                    continue

                assert(self.is_backup())
                if is_client(instance): 
                    if type != MessageType.HEALTH_UPDATE:
                        received_id = instance.received_ids[0]
                        if received_id == message_id: 
                            instance.received_ids.pop(0)
                        if message_id &gt; received_id:
                            myprint(Verbosity.all, 
                                    f&#34;{instance.name}   {type}   {body}   message_id={message_id}   received_id={received_id}&#34;)
                            assert(False)
                    continue

                assert(is_primary(instance))
                if type != MessageType.MESSAGE_FROM_CLIENT:
                    self.process_message(instance, type, body)
                    continue
                
                assert(type == MessageType.MESSAGE_FROM_CLIENT)
                name, orig_id, message_type, message_body = body
                client = self.get_client(name)
                if not client:
                    myprint(Verbosity.all, 
                            f&#34;The instance object {name} does not exist anymore&#34;)
                    return

                myprint(Verbosity.messages, 
                        f&#34;Handling message {orig_id} ({message_type}) from {client.name}&#34;)
                client.received_ids.append(orig_id)
                self.process_message(client, message_type, message_body)

#endregion PROCESSING MESSAGES</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ExpoCloud.src.server.Server"><code class="flex name class">
<span>class <span class="ident">Server</span></span>
<span>(</span><span>tasks, engine, backup, max_clients=None, max_cpus_per_client=None, min_group_size=0)</span>
</code></dt>
<dd>
<div class="desc"><p>An instance of this class is either a primary or a backup server.</p>
<p>Note that this constructor is only ever involked for building the first primary server.
<code>backup</code> - whether a backup server should be used.
<code>min_group_size</code> - minimal size of group defined by the Task's <code>group_parameter_titles</code> method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Server():
    &#34;&#34;&#34;
    An instance of this class is either a primary or a backup server.
    &#34;&#34;&#34;
    def __init__(self, tasks, engine, backup, 
                 max_clients = None, max_cpus_per_client = None, 
                 min_group_size = 0):
        &#34;&#34;&#34;
        Note that this constructor is only ever involked for building the first primary server.
        `backup` - whether a backup server should be used.
        `min_group_size` - minimal size of group defined by the Task&#39;s `group_parameter_titles` method.
        &#34;&#34;&#34;
        myprint(Verbosity.all, &#34;Constructing the server&#34;)
        self.role = InstanceRole.PRIMARY_SERVER
        self.port = util.get_unused_port()
        self.engine = engine
        self.backup = backup
        self.max_clients = max_clients
        self.max_cpus_per_client = max_cpus_per_client
        self.clients = []
        self.clients_stopped_timestamp = None

        self.init_handshake_q()

        # Store original order for results output, then sort by difficulty
        for i, t in enumerate(tasks): 
            t.orig_id = i
        self.tasks = sorted(tasks, key = lambda t: t.hardness)
        self.next_task = 0 # next task to be given to clients
        self.tasks_from_failed = [] # tasks from failed clients to reassign
        self.min_hard = [] # hardness for each minimally hard task
        self.min_group_size = min_group_size

        for i, t in enumerate(self.tasks):
            t.id = i
            t.result = None
        
        self.output_folder = util.output_folder()
        os.makedirs(self.output_folder, exist_ok=True)
        
        self.primary_server = None
        self.backup_server = None
        self.to_client_id = 1000 # id of the next outbound message to a client
        
    def __del__(self):
        myprint(Verbosity.all, &#34;Shutting down&#34;)
        if self.is_primary():
            self.handshake_manager.shutdown()

    def run(self):
        if self.is_primary():
            myprint(Verbosity.all, 
                    f&#34;Got {len(self.tasks)} tasks and ready for clients&#34;)

        try:
            printed_results = False
            while True:
                self.send_health_update()
                if self.is_primary(): self.accept_handshakes()
                self.handle_messages()
                if self.is_primary(): self.create_instance()
                self.kill_unhealthy_instances()
                if not printed_results:
                    if not (self.tasks_remain() or self.clients):
                        self.print_results()
                        printed_results = True
                time.sleep(Constants.SERVER_CYCLE_WAIT)
        except Exception as e:
            handle_exception(e, &#34;Exception in Server.run&#34;)
        

#region TASKS

    def tasks_remain(self):
        &#34;&#34;&#34;
        Return True if tasks to execute remain.
        &#34;&#34;&#34;
        return self.tasks_from_failed or self.next_task &lt; len(self.tasks)

    def is_hard(self, hardness):
        &#34;&#34;&#34;
        Check whether `hardness` is hard.
        &#34;&#34;&#34;
        for h in self.min_hard:
            if hardness &gt;= h: return True
        return False

    def print_results(self):
        &#34;&#34;&#34;
        Restore the original order of tasks and print results.
        &#34;&#34;&#34;
        myprint(Verbosity.all, &#34;Printing results&#34;)
        group_counts = {}
        for t in self.tasks:
            group = t.group_parameters()
            if group not in group_counts: group_counts[group] = 0
            group_counts[group] += 1

        self.tasks.sort(key = lambda t: t.orig_id)

        results_file = \
            open(os.path.join(self.output_folder, &#39;results.txt&#39;), &#34;w&#34;)
        print(util.tuple_to_csv(self.tasks[0].parameter_titles() + \
                                self.tasks[0].result_titles()),
              file = results_file)
        for t in self.tasks:
            if not t.result: continue
            if group_counts[t.group_parameters()] &gt;= self.min_group_size:
                print(util.tuple_to_csv(t.parameters() + t.result), 
                      file = results_file)
        
        results_file.close()
        myprint(Verbosity.all, &#34;Done printing results&#34;)

#endregion TASKS

#region ROLES

    def is_primary(self):
        return self.role == InstanceRole.PRIMARY_SERVER

    def is_backup(self):
        return self.role == InstanceRole.BACKUP_SERVER

    def assume_backup_role(self):
        &#34;&#34;&#34;
        This method is called after unpickling the primary server object, so as to convert it to a backup server one.
        &#34;&#34;&#34;
        assert(self.is_primary())
        self.role = InstanceRole.BACKUP_SERVER
        self.output_folder = util.output_folder(util.command_arg_name())
        self.backup_server = None

        self.port = util.get_unused_port()
        self.primary_server = PrimaryServerInstance(self.port)
        util.handshake(self.role, self.port)
        myprint(Verbosity.all, &#34;Handshake with primary server complete&#34;)

        if len(self.clients) &gt; 0 and not self.clients[-1].active_timestamp:
            self.clients = self.clients[:-1]
            
        for c in self.clients:
            c.shake_hands(self.role, self.output_folder)
            c.engine = None
            c.received_ids = []
    
    def assume_primary_role(self):
        &#34;&#34;&#34;
        Assume the role of the primary server. This is called when primary server failure is detected.
        &#34;&#34;&#34;
        assert(self.is_backup())
        self.role = InstanceRole.PRIMARY_SERVER
        self.primary_server = None
        self.backup_server = None
        self.init_handshake_q()
        for c in self.clients: c.engine = self.engine
    
    def handle_primary_server_failure(self):
        myprint(Verbosity.all, &#34;Handling primary server failure&#34;)
        self.assume_primary_role()
        for c in self.clients:
            if not c.active_timestamp: continue
            temp = c.outbound_q
            try:
                c.outbound_q, = util.get_guest_qs(
                    c.ip, c.port_primary, [&#39;inbound&#39;])
            except:
                myprint(Verbosity.all, 
                        &#34;Temporary connection to from_primary_q failed&#34;)
            self.message_to_instance(c, MessageType.SWAP_QUEUES, None)
            c.port_primary, c.port_backup = c.port_backup, c.port_primary
            c.outbound_q = temp
            c.engine = self.engine
#endregion ROLES

#region INSTANCES

    def init_handshake_q(self):
        self.handshake_manager = \
            util.make_manager([&#39;handshake_q&#39;], self.port)
        self.handshake_q = self.handshake_manager.handshake_q()

    def handshake_from_client(self, name, port_primary, port_backup):
        client = self.get_client(name)
        if not client:
            myprint(Verbosity.all, f&#34;Unknown client {name} tried to connect&#34;)
            return
        client.port_primary, client.port_backup = port_primary, port_backup
        client.shake_hands(self.role, self.output_folder)

        # inform the backup server
        myprint(Verbosity.all, f&#34;Informing backup server of {client.name}&#34;)
        self.message_to_instance(
            self.backup_server, MessageType.NEW_CLIENT, 
                (client.name, client.ip, 
                 port_primary, port_backup, client.active_timestamp))
    
    def handshake_from_backup(self, name, port):
        if name != self.backup_server.name:
            myprint(Verbosity.all, 
                    f&#34;Unknown backup server {name} tried to connect&#34;)
            return
        self.backup_server.port = port
        self.backup_server.shake_hands()
        self.resume_clients()

    def accept_handshakes(self):
        while not self.handshake_q.empty():
            body = self.handshake_q.get_nowait()
            role, rest = body[0], body[1:]
            
            if role == InstanceRole.CLIENT:
                if self.clients_stopped_timestamp:
                    self.handshake_q.put(body)
                    continue
                name, port_primary, port_backup = rest
                self.handshake_from_client(name, port_primary, port_backup)
                continue

            if role == InstanceRole.BACKUP_SERVER:
                name, port = rest
                self.handshake_from_backup(name, port)
                continue

            assert(False)

    def n_active_clients(self):
        return len(list(filter(lambda c: c.active_timestamp, self.clients)))

    def get_client(self, name):
        try:
            return next(filter(lambda c: c.name == name, self.clients))
        except:
            return None

    def kill_client(self, name):
        self.clients = \
            list(filter(lambda c: c.name != name, self.clients))

    def kill_instance(self, instance):
        if is_client(instance):
            self.kill_client(instance.name)
            return
        if is_backup(instance):
            self.backup_server = None
            return
        if is_primary(instance):
            self.handle_primary_server_failure()
            return
        assert(False)
    
    def create_backup_server_instance(self):
        def pickle_server():
            # exclude things that should not be pickled/unpickled
            temp_handshake_manager, temp_handhsake_q, temp_backup_server = \
                self.handshake_manager, self.handshake_q, self.backup_server
            self.handshake_manager, self.handshake_q, self.backup_server = \
                None, None, None
            client_files = []
            for c in self.clients:
                if not c.active_timestamp: continue
                client_files.append((c.events_file, c.exceptions_file))
                c.events_file, c.exceptions_file = None, None
            with open(util.pickled_file_name(self.output_folder), &#39;wb&#39;) as f:
                pickle.dump(self, f)
            self.handshake_manager, self.handshake_q, self.backup_server = \
                temp_handshake_manager, temp_handhsake_q, temp_backup_server
            for c in self.clients:
                if not c.active_timestamp: continue
                c.events_file, c.exceptions_file  = client_files.pop(0)
        
        def copy_output_folder():
            backup_output_folder = \
                    util.output_folder(self.backup_server.name)
            if not self.engine.is_local():
                util.remote_replace(
                    self.backup_server.ip, 
                    self.output_folder,
                    os.path.join(self.engine.root_folder, 
                                 backup_output_folder))
            else:
                command = f&#34;cp -r {self.output_folder} {backup_output_folder}&#34;
                subprocess.check_output(command, shell=True)

        # If not first backup server instance, make sure all clients got the STOP message and all client messages had been handled
        if self.clients_stopped_timestamp:
            if time.time() - self.clients_stopped_timestamp &lt;= \
               Constants.CLIENTS_TIME_TO_STOP: 
               return
            for c in self.clients:
                if self.messages_waiting(c): return

        if not self.backup_server:
            self.backup_server = BackupServerInstance(self.engine)
            self.backup_server_has_been_run = False
            myprint(Verbosity.all, 
                    f&#34;Created instance object for {self.backup_server.name}. Stopping clients...&#34;)
            self.stop_clients()
            return

        assert(self.backup_server)
        if not self.backup_server.ip:
            self.backup_server.create()
            return

        assert(self.backup_server.ip)
        if self.backup_server_has_been_run: return
        pickle_server()
        copy_output_folder()
        self.backup_server.run(self.port)
        self.backup_server_has_been_run = True

    def create_client_instance(self):
        # If no more tasks, don&#39;t create another client
        if not self.tasks_remain(): return

        # Make a client if all existing clients have ip
        if len(self.clients) == 0 or self.clients[-1].ip:
            client = ClientInstance(self.engine, self.tasks_from_failed)
            self.clients.append(client)
            myprint(Verbosity.all, f&#34;Created instance object for {client.name}&#34;)
        client = self.clients[-1]
        if not client.ip: client.create()
        if client.ip: client.run(self.port, self.max_cpus_per_client)

    def create_instance(self):
        if self.backup and \
            (not self.backup_server or not self.backup_server.active_timestamp):
            self.create_backup_server_instance()
        else:
            if (not self.max_clients) or \
               self.n_active_clients() &lt; self.max_clients:
                self.create_client_instance()

    def kill_unhealthy_instances(self):
        if self.is_backup():
            if not self.primary_server.is_healthy():
                self.handle_primary_server_failure()     
            return
        
        assert(self.is_primary())
        tasks_remain = self.tasks_remain()
        for c in self.clients:
            if c.is_healthy(tasks_remain): continue
            self.kill_client(c.name)
            self.message_to_instance(
                self.backup_server, MessageType.CLIENT_TERMINATED, c.name)
        
        if self.backup_server and \
           not self.backup_server.is_healthy(tasks_remain):
            self.backup_server = None

    def stop_clients(self):
        for c in self.clients:
            self.message_to_instance(c, MessageType.STOP, None)
        self.clients_stopped_timestamp = time.time()
    
    def resume_clients(self):
        for c in self.clients:
            self.message_to_instance(c, MessageType.RESUME, None)
        self.clients_stopped_timestamp = None

    def send_health_update(self):
        &#34;&#34;&#34;
        Send health update to the other server.
        &#34;&#34;&#34;
        other_server = \
            self.backup_server if self.is_primary() else self.primary_server
        self.message_to_instance(
            other_server, MessageType.HEALTH_UPDATE, None)

#endregion INSTANCES

#region MESSAGES
    def message_to_instance(self, instance, type, body):
        if not instance or not instance.active_timestamp:
            return

        try:
            message = (type, body)
            if is_client(instance) and \
               type not in [MessageType.STOP, MessageType.RESUME]:
                message = (self.to_client_id,) + message
                myprint(Verbosity.messages, 
                        f&#34;Sending message {self.to_client_id} ({type}) to {instance.name}&#34;)
                self.to_client_id += 1
            else:
                message = (None,) + message
            instance.outbound_q.put(message)
        except:
            myprint(Verbosity.all, f&#34;Sending to {instance.name} failed&#34;)
            myprint(Verbosity.failure_traceback, traceback.format_exc())
            self.kill_instance(instance)

    def messages_waiting(self, instance):
        &#34;&#34;&#34;
        Checks whether a message from `instance` can be read.
        If intance is invalid or is not active, return False.
        If there is no message in the inbound queue from the `instance`, return False. Otherwise return True, unless it is the backup server, `instance` is a client and there is no stored message id for this client.
        &#34;&#34;&#34;
        try:
            if not instance or not instance.active_timestamp: return False
            if instance.inbound_q.empty(): return False
            
            if self.is_primary(): return True

            assert(self.is_backup())
            if not is_client(instance): return True
            if not instance.received_ids: return False
            return True
        except:
            myprint(Verbosity.all, f&#34;Listening to {instance.name} failed&#34;)
            myprint(Verbosity.failure_traceback, traceback.format_exc())
            self.kill_instance(instance)

    def forward_message(self, instance, message_id, type, body):
        &#34;&#34;&#34;
        Forward messages from clients except health updates to backup server.
        &#34;&#34;&#34;
        if instance.role != InstanceRole.CLIENT: return
        self.message_to_instance(
            self.backup_server, MessageType.MESSAGE_FROM_CLIENT, 
            (instance.name, message_id, type, body))

#endregion MESSAGES

#region PROCESSING MESSAGES

    def process_health_update(self, instance, _body):
        instance.active_timestamp = time.time()

    def process_request_tasks(self, client: ClientInstance, n: int):
        tasks = []
        while n &gt; 0 and self.tasks_remain():
            task = self.tasks[self.next_task]
            if self.tasks_from_failed:
                task = self.tasks[self.tasks_from_failed.pop(0)]
            else:
                self.next_task += 1
            if self.is_hard(task.hardness):
                myprint(Verbosity.all, f&#34;Skipping hard task {task.id}&#34;)
                continue
            tasks.append(task)
            n -= 1
        if tasks:
            try:
                client.register_tasks(tasks)
                self.message_to_instance(
                    client, MessageType.GRANT_TASKS, tasks)
            except Exception as e:
                handle_exception(e, &#34;Failed to send tasks&#34;)
        if n &gt; 0:
            self.message_to_instance(
                client, MessageType.NO_FURTHER_TASKS, None)

    def process_log(self, client, descr):
        print(descr, file=client.events_file, flush=True)

    def process_exception(self, client, descr):
        print(descr, file=client.exceptions_file, flush=True)

    def process_result(self, client, body):
        id, result = body
        myprint(Verbosity.all, f&#34;Client {client.name} - result for task {id}&#34;)
        client.unregister_task(id)
        task = self.tasks[id]
        task.result = result
            
    def process_report_hard_task(self, _client, task_id):
        &#34;&#34;&#34;
        Handle the overdue task: 
        1. After checking again that the task is minimally hard, add the task to self.min_hard.
        2. Send this task to all clients for application of domino effect. Note: this is suboptimal as far as network capacity is concerned, but simplifies the server, which does not need to maintain which tasks are currently worked on by each client. 
        &#34;&#34;&#34;
        hardness = self.tasks[task_id].hardness
        if self.is_hard(hardness): return # not minimally hard
        self.min_hard.append(hardness)
        
        for c in self.clients:
            c.unregister_domino(self.tasks, hardness)
            self.message_to_instance(
                c, MessageType.APPLY_DOMINO_EFFECT, hardness)

    def process_bye(self, client, _body):
        assert(is_client(client))
        myprint(Verbosity.all, 
                f&#34;Got bye from {client.name}; {len(client.my_tasks)} registered tasks remain&#34;)
        self.kill_instance(client)

    def process_new_client(self, _instance, body):
        assert(self.is_backup())
        self.engine.next_instance_name(InstanceRole.CLIENT)
        client = ClientInstance(None, self.tasks_from_failed)
        client.name, client.ip, client.port_primary, client.port_backup, \
            client.active_timestamp = body
        myprint(Verbosity.all, f&#34;New {client.name}&#34;)
        client.shake_hands(self.role, self.output_folder)
        self.clients.append(client)

    def process_client_terminated(self, _instance, client_name):
        &#34;&#34;&#34;
        Process client failure reported by the primary server.
        &#34;&#34;&#34;
        assert(self.is_backup())
        myprint(Verbosity.all, 
                f&#34;Client {client_name} was terminated by primary server&#34;)
        self.kill_client(client_name)

    def process_message(self, instance, type, body):
        {
        MessageType.HEALTH_UPDATE: self.process_health_update,
        MessageType.REQUEST_TASKS: self.process_request_tasks,
        MessageType.RESULT: self.process_result,
        MessageType.REPORT_HARD_TASK: self.process_report_hard_task,
        MessageType.LOG: self.process_log,
        MessageType.EXCEPTION: self.process_exception,
        MessageType.BYE: self.process_bye,

        MessageType.NEW_CLIENT: self.process_new_client,
        MessageType.CLIENT_TERMINATED: self.process_client_terminated,
        } [type](instance, body)

    def handle_messages(self):
        &#34;&#34;&#34;
        Handle messages from instances.
        &#34;&#34;&#34;
        for instance in \
            self.clients + [self.primary_server, self.backup_server]:
            
            while self.messages_waiting(instance):
                message_id, type, body = instance.inbound_q.get_nowait()
                
                myprint(type != MessageType.HEALTH_UPDATE and \
                        Verbosity.all_non_health_messages, 
                        f&#34;Got {message_id} of type {type} from {instance.role}&#34;)
                if self.is_primary():
                    if is_client(instance):
                        if type != MessageType.HEALTH_UPDATE:
                            myprint(Verbosity.messages, 
                                    f&#34;Handling message {message_id} ({type}) from {instance.name}&#34;)
                            self.forward_message(instance, message_id, type, body)
                    self.process_message(instance, type, body)
                    continue

                assert(self.is_backup())
                if is_client(instance): 
                    if type != MessageType.HEALTH_UPDATE:
                        received_id = instance.received_ids[0]
                        if received_id == message_id: 
                            instance.received_ids.pop(0)
                        if message_id &gt; received_id:
                            myprint(Verbosity.all, 
                                    f&#34;{instance.name}   {type}   {body}   message_id={message_id}   received_id={received_id}&#34;)
                            assert(False)
                    continue

                assert(is_primary(instance))
                if type != MessageType.MESSAGE_FROM_CLIENT:
                    self.process_message(instance, type, body)
                    continue
                
                assert(type == MessageType.MESSAGE_FROM_CLIENT)
                name, orig_id, message_type, message_body = body
                client = self.get_client(name)
                if not client:
                    myprint(Verbosity.all, 
                            f&#34;The instance object {name} does not exist anymore&#34;)
                    return

                myprint(Verbosity.messages, 
                        f&#34;Handling message {orig_id} ({message_type}) from {client.name}&#34;)
                client.received_ids.append(orig_id)
                self.process_message(client, message_type, message_body)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ExpoCloud.src.server.Server.accept_handshakes"><code class="name flex">
<span>def <span class="ident">accept_handshakes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accept_handshakes(self):
    while not self.handshake_q.empty():
        body = self.handshake_q.get_nowait()
        role, rest = body[0], body[1:]
        
        if role == InstanceRole.CLIENT:
            if self.clients_stopped_timestamp:
                self.handshake_q.put(body)
                continue
            name, port_primary, port_backup = rest
            self.handshake_from_client(name, port_primary, port_backup)
            continue

        if role == InstanceRole.BACKUP_SERVER:
            name, port = rest
            self.handshake_from_backup(name, port)
            continue

        assert(False)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.assume_backup_role"><code class="name flex">
<span>def <span class="ident">assume_backup_role</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is called after unpickling the primary server object, so as to convert it to a backup server one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assume_backup_role(self):
    &#34;&#34;&#34;
    This method is called after unpickling the primary server object, so as to convert it to a backup server one.
    &#34;&#34;&#34;
    assert(self.is_primary())
    self.role = InstanceRole.BACKUP_SERVER
    self.output_folder = util.output_folder(util.command_arg_name())
    self.backup_server = None

    self.port = util.get_unused_port()
    self.primary_server = PrimaryServerInstance(self.port)
    util.handshake(self.role, self.port)
    myprint(Verbosity.all, &#34;Handshake with primary server complete&#34;)

    if len(self.clients) &gt; 0 and not self.clients[-1].active_timestamp:
        self.clients = self.clients[:-1]
        
    for c in self.clients:
        c.shake_hands(self.role, self.output_folder)
        c.engine = None
        c.received_ids = []</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.assume_primary_role"><code class="name flex">
<span>def <span class="ident">assume_primary_role</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Assume the role of the primary server. This is called when primary server failure is detected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assume_primary_role(self):
    &#34;&#34;&#34;
    Assume the role of the primary server. This is called when primary server failure is detected.
    &#34;&#34;&#34;
    assert(self.is_backup())
    self.role = InstanceRole.PRIMARY_SERVER
    self.primary_server = None
    self.backup_server = None
    self.init_handshake_q()
    for c in self.clients: c.engine = self.engine</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.create_backup_server_instance"><code class="name flex">
<span>def <span class="ident">create_backup_server_instance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_backup_server_instance(self):
    def pickle_server():
        # exclude things that should not be pickled/unpickled
        temp_handshake_manager, temp_handhsake_q, temp_backup_server = \
            self.handshake_manager, self.handshake_q, self.backup_server
        self.handshake_manager, self.handshake_q, self.backup_server = \
            None, None, None
        client_files = []
        for c in self.clients:
            if not c.active_timestamp: continue
            client_files.append((c.events_file, c.exceptions_file))
            c.events_file, c.exceptions_file = None, None
        with open(util.pickled_file_name(self.output_folder), &#39;wb&#39;) as f:
            pickle.dump(self, f)
        self.handshake_manager, self.handshake_q, self.backup_server = \
            temp_handshake_manager, temp_handhsake_q, temp_backup_server
        for c in self.clients:
            if not c.active_timestamp: continue
            c.events_file, c.exceptions_file  = client_files.pop(0)
    
    def copy_output_folder():
        backup_output_folder = \
                util.output_folder(self.backup_server.name)
        if not self.engine.is_local():
            util.remote_replace(
                self.backup_server.ip, 
                self.output_folder,
                os.path.join(self.engine.root_folder, 
                             backup_output_folder))
        else:
            command = f&#34;cp -r {self.output_folder} {backup_output_folder}&#34;
            subprocess.check_output(command, shell=True)

    # If not first backup server instance, make sure all clients got the STOP message and all client messages had been handled
    if self.clients_stopped_timestamp:
        if time.time() - self.clients_stopped_timestamp &lt;= \
           Constants.CLIENTS_TIME_TO_STOP: 
           return
        for c in self.clients:
            if self.messages_waiting(c): return

    if not self.backup_server:
        self.backup_server = BackupServerInstance(self.engine)
        self.backup_server_has_been_run = False
        myprint(Verbosity.all, 
                f&#34;Created instance object for {self.backup_server.name}. Stopping clients...&#34;)
        self.stop_clients()
        return

    assert(self.backup_server)
    if not self.backup_server.ip:
        self.backup_server.create()
        return

    assert(self.backup_server.ip)
    if self.backup_server_has_been_run: return
    pickle_server()
    copy_output_folder()
    self.backup_server.run(self.port)
    self.backup_server_has_been_run = True</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.create_client_instance"><code class="name flex">
<span>def <span class="ident">create_client_instance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_client_instance(self):
    # If no more tasks, don&#39;t create another client
    if not self.tasks_remain(): return

    # Make a client if all existing clients have ip
    if len(self.clients) == 0 or self.clients[-1].ip:
        client = ClientInstance(self.engine, self.tasks_from_failed)
        self.clients.append(client)
        myprint(Verbosity.all, f&#34;Created instance object for {client.name}&#34;)
    client = self.clients[-1]
    if not client.ip: client.create()
    if client.ip: client.run(self.port, self.max_cpus_per_client)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.create_instance"><code class="name flex">
<span>def <span class="ident">create_instance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_instance(self):
    if self.backup and \
        (not self.backup_server or not self.backup_server.active_timestamp):
        self.create_backup_server_instance()
    else:
        if (not self.max_clients) or \
           self.n_active_clients() &lt; self.max_clients:
            self.create_client_instance()</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.forward_message"><code class="name flex">
<span>def <span class="ident">forward_message</span></span>(<span>self, instance, message_id, type, body)</span>
</code></dt>
<dd>
<div class="desc"><p>Forward messages from clients except health updates to backup server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forward_message(self, instance, message_id, type, body):
    &#34;&#34;&#34;
    Forward messages from clients except health updates to backup server.
    &#34;&#34;&#34;
    if instance.role != InstanceRole.CLIENT: return
    self.message_to_instance(
        self.backup_server, MessageType.MESSAGE_FROM_CLIENT, 
        (instance.name, message_id, type, body))</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.get_client"><code class="name flex">
<span>def <span class="ident">get_client</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_client(self, name):
    try:
        return next(filter(lambda c: c.name == name, self.clients))
    except:
        return None</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.handle_messages"><code class="name flex">
<span>def <span class="ident">handle_messages</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle messages from instances.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_messages(self):
    &#34;&#34;&#34;
    Handle messages from instances.
    &#34;&#34;&#34;
    for instance in \
        self.clients + [self.primary_server, self.backup_server]:
        
        while self.messages_waiting(instance):
            message_id, type, body = instance.inbound_q.get_nowait()
            
            myprint(type != MessageType.HEALTH_UPDATE and \
                    Verbosity.all_non_health_messages, 
                    f&#34;Got {message_id} of type {type} from {instance.role}&#34;)
            if self.is_primary():
                if is_client(instance):
                    if type != MessageType.HEALTH_UPDATE:
                        myprint(Verbosity.messages, 
                                f&#34;Handling message {message_id} ({type}) from {instance.name}&#34;)
                        self.forward_message(instance, message_id, type, body)
                self.process_message(instance, type, body)
                continue

            assert(self.is_backup())
            if is_client(instance): 
                if type != MessageType.HEALTH_UPDATE:
                    received_id = instance.received_ids[0]
                    if received_id == message_id: 
                        instance.received_ids.pop(0)
                    if message_id &gt; received_id:
                        myprint(Verbosity.all, 
                                f&#34;{instance.name}   {type}   {body}   message_id={message_id}   received_id={received_id}&#34;)
                        assert(False)
                continue

            assert(is_primary(instance))
            if type != MessageType.MESSAGE_FROM_CLIENT:
                self.process_message(instance, type, body)
                continue
            
            assert(type == MessageType.MESSAGE_FROM_CLIENT)
            name, orig_id, message_type, message_body = body
            client = self.get_client(name)
            if not client:
                myprint(Verbosity.all, 
                        f&#34;The instance object {name} does not exist anymore&#34;)
                return

            myprint(Verbosity.messages, 
                    f&#34;Handling message {orig_id} ({message_type}) from {client.name}&#34;)
            client.received_ids.append(orig_id)
            self.process_message(client, message_type, message_body)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.handle_primary_server_failure"><code class="name flex">
<span>def <span class="ident">handle_primary_server_failure</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_primary_server_failure(self):
    myprint(Verbosity.all, &#34;Handling primary server failure&#34;)
    self.assume_primary_role()
    for c in self.clients:
        if not c.active_timestamp: continue
        temp = c.outbound_q
        try:
            c.outbound_q, = util.get_guest_qs(
                c.ip, c.port_primary, [&#39;inbound&#39;])
        except:
            myprint(Verbosity.all, 
                    &#34;Temporary connection to from_primary_q failed&#34;)
        self.message_to_instance(c, MessageType.SWAP_QUEUES, None)
        c.port_primary, c.port_backup = c.port_backup, c.port_primary
        c.outbound_q = temp
        c.engine = self.engine</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.handshake_from_backup"><code class="name flex">
<span>def <span class="ident">handshake_from_backup</span></span>(<span>self, name, port)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handshake_from_backup(self, name, port):
    if name != self.backup_server.name:
        myprint(Verbosity.all, 
                f&#34;Unknown backup server {name} tried to connect&#34;)
        return
    self.backup_server.port = port
    self.backup_server.shake_hands()
    self.resume_clients()</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.handshake_from_client"><code class="name flex">
<span>def <span class="ident">handshake_from_client</span></span>(<span>self, name, port_primary, port_backup)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handshake_from_client(self, name, port_primary, port_backup):
    client = self.get_client(name)
    if not client:
        myprint(Verbosity.all, f&#34;Unknown client {name} tried to connect&#34;)
        return
    client.port_primary, client.port_backup = port_primary, port_backup
    client.shake_hands(self.role, self.output_folder)

    # inform the backup server
    myprint(Verbosity.all, f&#34;Informing backup server of {client.name}&#34;)
    self.message_to_instance(
        self.backup_server, MessageType.NEW_CLIENT, 
            (client.name, client.ip, 
             port_primary, port_backup, client.active_timestamp))</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.init_handshake_q"><code class="name flex">
<span>def <span class="ident">init_handshake_q</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_handshake_q(self):
    self.handshake_manager = \
        util.make_manager([&#39;handshake_q&#39;], self.port)
    self.handshake_q = self.handshake_manager.handshake_q()</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.is_backup"><code class="name flex">
<span>def <span class="ident">is_backup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_backup(self):
    return self.role == InstanceRole.BACKUP_SERVER</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.is_hard"><code class="name flex">
<span>def <span class="ident">is_hard</span></span>(<span>self, hardness)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether <code>hardness</code> is hard.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_hard(self, hardness):
    &#34;&#34;&#34;
    Check whether `hardness` is hard.
    &#34;&#34;&#34;
    for h in self.min_hard:
        if hardness &gt;= h: return True
    return False</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.is_primary"><code class="name flex">
<span>def <span class="ident">is_primary</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_primary(self):
    return self.role == InstanceRole.PRIMARY_SERVER</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.kill_client"><code class="name flex">
<span>def <span class="ident">kill_client</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kill_client(self, name):
    self.clients = \
        list(filter(lambda c: c.name != name, self.clients))</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.kill_instance"><code class="name flex">
<span>def <span class="ident">kill_instance</span></span>(<span>self, instance)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kill_instance(self, instance):
    if is_client(instance):
        self.kill_client(instance.name)
        return
    if is_backup(instance):
        self.backup_server = None
        return
    if is_primary(instance):
        self.handle_primary_server_failure()
        return
    assert(False)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.kill_unhealthy_instances"><code class="name flex">
<span>def <span class="ident">kill_unhealthy_instances</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kill_unhealthy_instances(self):
    if self.is_backup():
        if not self.primary_server.is_healthy():
            self.handle_primary_server_failure()     
        return
    
    assert(self.is_primary())
    tasks_remain = self.tasks_remain()
    for c in self.clients:
        if c.is_healthy(tasks_remain): continue
        self.kill_client(c.name)
        self.message_to_instance(
            self.backup_server, MessageType.CLIENT_TERMINATED, c.name)
    
    if self.backup_server and \
       not self.backup_server.is_healthy(tasks_remain):
        self.backup_server = None</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.message_to_instance"><code class="name flex">
<span>def <span class="ident">message_to_instance</span></span>(<span>self, instance, type, body)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def message_to_instance(self, instance, type, body):
    if not instance or not instance.active_timestamp:
        return

    try:
        message = (type, body)
        if is_client(instance) and \
           type not in [MessageType.STOP, MessageType.RESUME]:
            message = (self.to_client_id,) + message
            myprint(Verbosity.messages, 
                    f&#34;Sending message {self.to_client_id} ({type}) to {instance.name}&#34;)
            self.to_client_id += 1
        else:
            message = (None,) + message
        instance.outbound_q.put(message)
    except:
        myprint(Verbosity.all, f&#34;Sending to {instance.name} failed&#34;)
        myprint(Verbosity.failure_traceback, traceback.format_exc())
        self.kill_instance(instance)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.messages_waiting"><code class="name flex">
<span>def <span class="ident">messages_waiting</span></span>(<span>self, instance)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether a message from <code>instance</code> can be read.
If intance is invalid or is not active, return False.
If there is no message in the inbound queue from the <code>instance</code>, return False. Otherwise return True, unless it is the backup server, <code>instance</code> is a client and there is no stored message id for this client.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def messages_waiting(self, instance):
    &#34;&#34;&#34;
    Checks whether a message from `instance` can be read.
    If intance is invalid or is not active, return False.
    If there is no message in the inbound queue from the `instance`, return False. Otherwise return True, unless it is the backup server, `instance` is a client and there is no stored message id for this client.
    &#34;&#34;&#34;
    try:
        if not instance or not instance.active_timestamp: return False
        if instance.inbound_q.empty(): return False
        
        if self.is_primary(): return True

        assert(self.is_backup())
        if not is_client(instance): return True
        if not instance.received_ids: return False
        return True
    except:
        myprint(Verbosity.all, f&#34;Listening to {instance.name} failed&#34;)
        myprint(Verbosity.failure_traceback, traceback.format_exc())
        self.kill_instance(instance)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.n_active_clients"><code class="name flex">
<span>def <span class="ident">n_active_clients</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def n_active_clients(self):
    return len(list(filter(lambda c: c.active_timestamp, self.clients)))</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.print_results"><code class="name flex">
<span>def <span class="ident">print_results</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Restore the original order of tasks and print results.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_results(self):
    &#34;&#34;&#34;
    Restore the original order of tasks and print results.
    &#34;&#34;&#34;
    myprint(Verbosity.all, &#34;Printing results&#34;)
    group_counts = {}
    for t in self.tasks:
        group = t.group_parameters()
        if group not in group_counts: group_counts[group] = 0
        group_counts[group] += 1

    self.tasks.sort(key = lambda t: t.orig_id)

    results_file = \
        open(os.path.join(self.output_folder, &#39;results.txt&#39;), &#34;w&#34;)
    print(util.tuple_to_csv(self.tasks[0].parameter_titles() + \
                            self.tasks[0].result_titles()),
          file = results_file)
    for t in self.tasks:
        if not t.result: continue
        if group_counts[t.group_parameters()] &gt;= self.min_group_size:
            print(util.tuple_to_csv(t.parameters() + t.result), 
                  file = results_file)
    
    results_file.close()
    myprint(Verbosity.all, &#34;Done printing results&#34;)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.process_bye"><code class="name flex">
<span>def <span class="ident">process_bye</span></span>(<span>self, client, _body)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_bye(self, client, _body):
    assert(is_client(client))
    myprint(Verbosity.all, 
            f&#34;Got bye from {client.name}; {len(client.my_tasks)} registered tasks remain&#34;)
    self.kill_instance(client)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.process_client_terminated"><code class="name flex">
<span>def <span class="ident">process_client_terminated</span></span>(<span>self, _instance, client_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Process client failure reported by the primary server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_client_terminated(self, _instance, client_name):
    &#34;&#34;&#34;
    Process client failure reported by the primary server.
    &#34;&#34;&#34;
    assert(self.is_backup())
    myprint(Verbosity.all, 
            f&#34;Client {client_name} was terminated by primary server&#34;)
    self.kill_client(client_name)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.process_exception"><code class="name flex">
<span>def <span class="ident">process_exception</span></span>(<span>self, client, descr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_exception(self, client, descr):
    print(descr, file=client.exceptions_file, flush=True)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.process_health_update"><code class="name flex">
<span>def <span class="ident">process_health_update</span></span>(<span>self, instance, _body)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_health_update(self, instance, _body):
    instance.active_timestamp = time.time()</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.process_log"><code class="name flex">
<span>def <span class="ident">process_log</span></span>(<span>self, client, descr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_log(self, client, descr):
    print(descr, file=client.events_file, flush=True)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.process_message"><code class="name flex">
<span>def <span class="ident">process_message</span></span>(<span>self, instance, type, body)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_message(self, instance, type, body):
    {
    MessageType.HEALTH_UPDATE: self.process_health_update,
    MessageType.REQUEST_TASKS: self.process_request_tasks,
    MessageType.RESULT: self.process_result,
    MessageType.REPORT_HARD_TASK: self.process_report_hard_task,
    MessageType.LOG: self.process_log,
    MessageType.EXCEPTION: self.process_exception,
    MessageType.BYE: self.process_bye,

    MessageType.NEW_CLIENT: self.process_new_client,
    MessageType.CLIENT_TERMINATED: self.process_client_terminated,
    } [type](instance, body)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.process_new_client"><code class="name flex">
<span>def <span class="ident">process_new_client</span></span>(<span>self, _instance, body)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_new_client(self, _instance, body):
    assert(self.is_backup())
    self.engine.next_instance_name(InstanceRole.CLIENT)
    client = ClientInstance(None, self.tasks_from_failed)
    client.name, client.ip, client.port_primary, client.port_backup, \
        client.active_timestamp = body
    myprint(Verbosity.all, f&#34;New {client.name}&#34;)
    client.shake_hands(self.role, self.output_folder)
    self.clients.append(client)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.process_report_hard_task"><code class="name flex">
<span>def <span class="ident">process_report_hard_task</span></span>(<span>self, _client, task_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle the overdue task:
1. After checking again that the task is minimally hard, add the task to self.min_hard.
2. Send this task to all clients for application of domino effect. Note: this is suboptimal as far as network capacity is concerned, but simplifies the server, which does not need to maintain which tasks are currently worked on by each client.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_report_hard_task(self, _client, task_id):
    &#34;&#34;&#34;
    Handle the overdue task: 
    1. After checking again that the task is minimally hard, add the task to self.min_hard.
    2. Send this task to all clients for application of domino effect. Note: this is suboptimal as far as network capacity is concerned, but simplifies the server, which does not need to maintain which tasks are currently worked on by each client. 
    &#34;&#34;&#34;
    hardness = self.tasks[task_id].hardness
    if self.is_hard(hardness): return # not minimally hard
    self.min_hard.append(hardness)
    
    for c in self.clients:
        c.unregister_domino(self.tasks, hardness)
        self.message_to_instance(
            c, MessageType.APPLY_DOMINO_EFFECT, hardness)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.process_request_tasks"><code class="name flex">
<span>def <span class="ident">process_request_tasks</span></span>(<span>self, client: src.instance.ClientInstance, n: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_request_tasks(self, client: ClientInstance, n: int):
    tasks = []
    while n &gt; 0 and self.tasks_remain():
        task = self.tasks[self.next_task]
        if self.tasks_from_failed:
            task = self.tasks[self.tasks_from_failed.pop(0)]
        else:
            self.next_task += 1
        if self.is_hard(task.hardness):
            myprint(Verbosity.all, f&#34;Skipping hard task {task.id}&#34;)
            continue
        tasks.append(task)
        n -= 1
    if tasks:
        try:
            client.register_tasks(tasks)
            self.message_to_instance(
                client, MessageType.GRANT_TASKS, tasks)
        except Exception as e:
            handle_exception(e, &#34;Failed to send tasks&#34;)
    if n &gt; 0:
        self.message_to_instance(
            client, MessageType.NO_FURTHER_TASKS, None)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.process_result"><code class="name flex">
<span>def <span class="ident">process_result</span></span>(<span>self, client, body)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_result(self, client, body):
    id, result = body
    myprint(Verbosity.all, f&#34;Client {client.name} - result for task {id}&#34;)
    client.unregister_task(id)
    task = self.tasks[id]
    task.result = result</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.resume_clients"><code class="name flex">
<span>def <span class="ident">resume_clients</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resume_clients(self):
    for c in self.clients:
        self.message_to_instance(c, MessageType.RESUME, None)
    self.clients_stopped_timestamp = None</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    if self.is_primary():
        myprint(Verbosity.all, 
                f&#34;Got {len(self.tasks)} tasks and ready for clients&#34;)

    try:
        printed_results = False
        while True:
            self.send_health_update()
            if self.is_primary(): self.accept_handshakes()
            self.handle_messages()
            if self.is_primary(): self.create_instance()
            self.kill_unhealthy_instances()
            if not printed_results:
                if not (self.tasks_remain() or self.clients):
                    self.print_results()
                    printed_results = True
            time.sleep(Constants.SERVER_CYCLE_WAIT)
    except Exception as e:
        handle_exception(e, &#34;Exception in Server.run&#34;)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.send_health_update"><code class="name flex">
<span>def <span class="ident">send_health_update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Send health update to the other server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_health_update(self):
    &#34;&#34;&#34;
    Send health update to the other server.
    &#34;&#34;&#34;
    other_server = \
        self.backup_server if self.is_primary() else self.primary_server
    self.message_to_instance(
        other_server, MessageType.HEALTH_UPDATE, None)</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.stop_clients"><code class="name flex">
<span>def <span class="ident">stop_clients</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_clients(self):
    for c in self.clients:
        self.message_to_instance(c, MessageType.STOP, None)
    self.clients_stopped_timestamp = time.time()</code></pre>
</details>
</dd>
<dt id="ExpoCloud.src.server.Server.tasks_remain"><code class="name flex">
<span>def <span class="ident">tasks_remain</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if tasks to execute remain.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tasks_remain(self):
    &#34;&#34;&#34;
    Return True if tasks to execute remain.
    &#34;&#34;&#34;
    return self.tasks_from_failed or self.next_task &lt; len(self.tasks)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ExpoCloud.src" href="index.html">ExpoCloud.src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ExpoCloud.src.server.Server" href="#ExpoCloud.src.server.Server">Server</a></code></h4>
<ul class="">
<li><code><a title="ExpoCloud.src.server.Server.accept_handshakes" href="#ExpoCloud.src.server.Server.accept_handshakes">accept_handshakes</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.assume_backup_role" href="#ExpoCloud.src.server.Server.assume_backup_role">assume_backup_role</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.assume_primary_role" href="#ExpoCloud.src.server.Server.assume_primary_role">assume_primary_role</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.create_backup_server_instance" href="#ExpoCloud.src.server.Server.create_backup_server_instance">create_backup_server_instance</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.create_client_instance" href="#ExpoCloud.src.server.Server.create_client_instance">create_client_instance</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.create_instance" href="#ExpoCloud.src.server.Server.create_instance">create_instance</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.forward_message" href="#ExpoCloud.src.server.Server.forward_message">forward_message</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.get_client" href="#ExpoCloud.src.server.Server.get_client">get_client</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.handle_messages" href="#ExpoCloud.src.server.Server.handle_messages">handle_messages</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.handle_primary_server_failure" href="#ExpoCloud.src.server.Server.handle_primary_server_failure">handle_primary_server_failure</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.handshake_from_backup" href="#ExpoCloud.src.server.Server.handshake_from_backup">handshake_from_backup</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.handshake_from_client" href="#ExpoCloud.src.server.Server.handshake_from_client">handshake_from_client</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.init_handshake_q" href="#ExpoCloud.src.server.Server.init_handshake_q">init_handshake_q</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.is_backup" href="#ExpoCloud.src.server.Server.is_backup">is_backup</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.is_hard" href="#ExpoCloud.src.server.Server.is_hard">is_hard</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.is_primary" href="#ExpoCloud.src.server.Server.is_primary">is_primary</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.kill_client" href="#ExpoCloud.src.server.Server.kill_client">kill_client</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.kill_instance" href="#ExpoCloud.src.server.Server.kill_instance">kill_instance</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.kill_unhealthy_instances" href="#ExpoCloud.src.server.Server.kill_unhealthy_instances">kill_unhealthy_instances</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.message_to_instance" href="#ExpoCloud.src.server.Server.message_to_instance">message_to_instance</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.messages_waiting" href="#ExpoCloud.src.server.Server.messages_waiting">messages_waiting</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.n_active_clients" href="#ExpoCloud.src.server.Server.n_active_clients">n_active_clients</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.print_results" href="#ExpoCloud.src.server.Server.print_results">print_results</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.process_bye" href="#ExpoCloud.src.server.Server.process_bye">process_bye</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.process_client_terminated" href="#ExpoCloud.src.server.Server.process_client_terminated">process_client_terminated</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.process_exception" href="#ExpoCloud.src.server.Server.process_exception">process_exception</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.process_health_update" href="#ExpoCloud.src.server.Server.process_health_update">process_health_update</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.process_log" href="#ExpoCloud.src.server.Server.process_log">process_log</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.process_message" href="#ExpoCloud.src.server.Server.process_message">process_message</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.process_new_client" href="#ExpoCloud.src.server.Server.process_new_client">process_new_client</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.process_report_hard_task" href="#ExpoCloud.src.server.Server.process_report_hard_task">process_report_hard_task</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.process_request_tasks" href="#ExpoCloud.src.server.Server.process_request_tasks">process_request_tasks</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.process_result" href="#ExpoCloud.src.server.Server.process_result">process_result</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.resume_clients" href="#ExpoCloud.src.server.Server.resume_clients">resume_clients</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.run" href="#ExpoCloud.src.server.Server.run">run</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.send_health_update" href="#ExpoCloud.src.server.Server.send_health_update">send_health_update</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.stop_clients" href="#ExpoCloud.src.server.Server.stop_clients">stop_clients</a></code></li>
<li><code><a title="ExpoCloud.src.server.Server.tasks_remain" href="#ExpoCloud.src.server.Server.tasks_remain">tasks_remain</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>